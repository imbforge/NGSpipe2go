---
title: "SHINYREPS_PROJECT"
output:
  html_document:
    toc: true
    toc_float: true
    css: styles.css
---

<div class="contentbox">





# Description

Enter project description here


# Processing

Enter pipeline description here.


```{r setup, echo=F, result='hide', error=F, warning=F, message=F}

# source helper functions
source("sc.shinyrep.helpers.R")


# load required packages
not_yet_attached <- attach_packages(c("tidyverse", "AnnotationDbi", "batchelor", "Biobase", "BiocSingular", "bluster", 
          "Cairo", "circlize", "chromVAR", "cluster", "ComplexHeatmap", "corrplot", "data.table", "dendextend", "DropletUtils", 
          "future", "GeneOverlap", "ggbeeswarm", "ggrepel", "gplots", "grid", "gridExtra", "igraph", "JASPAR2020", 
          "knitr", "kableExtra", "limma", "M3Drop", "Matrix", "parallel", "pbapply", "pheatmap", "pkgmaker", "plotly", "png", 
          "RColorBrewer", "reshape2", "rmarkdown", "rtracklayer", "Rtsne", "scales", "scater", "scDblFinder", "scran", "scuttle", 
          "Seurat", "SeuratDisk", "Signac", "shinydashboard", "TFBSTools", "uwot", "VennDiagram", "vipor", "viridis", "zellkonverter"))



# load global variables
loadGlobalVars(f="shinyReports.txt")

# load relevant BSgenome package (needed by Signac for motif analysis)
failed_BSgenome <- c("")
switch(SHINYREPS_DB,
    hg38={ failed_BSgenome <- attach_packages("BSgenome.Hsapiens.UCSC.hg38") },
    mm10={ failed_BSgenome <- attach_packages("BSgenome.Mmusculus.UCSC.mm10") },
    stop(c("Don't find genome:", SHINYREPS_DB))   
)
not_yet_attached <- c(not_yet_attached, failed_BSgenome)

# create folder for output files
if (!file.exists(file.path("report_files"))) {dir.create(file.path("report_files"))}

# set options
options(stringsAsFactors=FALSE)
CORES <- 2
pal   <- brewer.pal(9, "Set1")
pal_rb <- colorRampPalette(c(pal[1], "white", pal[2]))(20)
pal_y  <- colorRampPalette(c("black", "yellow"))(100)
plot_pointsize <- 1 # point size for plotReducedDim plots

knitr::opts_chunk$set(cache=F,
                      echo=F,
                      warning=F,
                      message=F,
                      dev='CairoPNG')

theme_set(theme_bw() + theme(axis.text=element_text(colour="grey30",size=12),
									axis.title=element_text(colour="grey30",size=14),
									plot.title=element_text(size=14,hjust=0.5),
									plot.subtitle=element_text(size=12,hjust=0.5),
									legend.text=element_text(size=12,colour="grey30"),
									legend.title=element_text(size=12,colour="grey30")))


runCutadapt <- SHINYREPS_RUN_CUTADAPT=="true" # check for selected pipeline modules 

## load pre-processed sc data
load(file.path(SHINYREPS_SC_READAGGRDATA_OUT, "sc_readAggrData.RData"))
load(file.path(SHINYREPS_RES, "gtf.RData"))
sobj <- readRDS(file = file.path(SHINYREPS_RES, "sobj.RDS"))


# print targets file
DT::datatable(targets, caption="targets file (sample sheet) used for analysis")
```

# Raw reads QC #

## FastQC of all reads

The raw sequence reads of all samples are analysed with the popular FastQC tool (http://www.bioinformatics.babraham.ac.uk/projects/fastqc/).

#### Read quality

The "read qualities" plot summarizes the mean quality score at each position.
The color on the graph shows the Phred quality scores, which are logarithmically related to the base-calling error probabilities. The higher the score the better the base call. The background of the graph divides the y axis into very good quality calls (green), calls of reasonable quality (yellow), and calls of poor quality (red). Typically, the majority of calls on all base positions fall into the green area. Due to binning of quality score in recent sequencing technologies (e.g. Illumina NextSeq), sequencing qualities are the same on many position and, thus, also samples appear to have very similar or almost identical sequencing qualities.


```{r FastQC_qual_summarized, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center'}
##### parameters to set:
# Select samples for which you would like to include fastqc results in the report. For single cell RNA-Seq with many cells, 
# you may want to restrict the total number of plots. If you provide a regular expression in 'samplePattern' only those 
# filenames will be included which match this expression, e.g. setting samplePattern="R1" yields only those fastq 
# files containing read1 of a read pair. This is recommended e.g. for MARS-Seq, where Read2 contains barcode information only.
# If you want to exclude samples according to the given certain pattern, define it in excludePattern. 
# If you set argument 'maxno', the maximum sample number will be restricted accordingly to the first 'maxno' plots. 
##### 

if (SHINYREPS_FASTQC_SUMMARIZED) {
    fastqc_summary_plot <- DEhelper.Fastqc.custom(web=F,summarizedPlots=T, targetsdf=targets4plots, samplePattern=SHINYREPS_SAMPLEPATTERN1, excludePattern=SHINYREPS_SAMPLEPATTERN2, maxno=SHINYREPS_MAXNO)
    plot(fastqc_summary_plot$p.qual)
    cat("\n", fill = T)
} else {
    fastqc_summary_plot <- DEhelper.Fastqc.custom(web=F,summarizedPlots=F, targetsdf=targets4plots, samplePattern=SHINYREPS_SAMPLEPATTERN1, excludePattern=SHINYREPS_SAMPLEPATTERN2, maxno=SHINYREPS_MAXNO)
}

```

```{r FastQC_qual, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center',fig.height=min(170, round((3*fastqc_summary_plot$no.of.samples)/4)+1)}
# REMARK: the maximal figure height is limited to 170 and will throw an error if exceeded ("Failed to create Cairo backend!"). For the not summarized plots you should limit the number of plots to 200 by using the maxno parameter. Otherwise the plots will be squeezed.

if (SHINYREPS_FASTQC_SUMMARIZED == FALSE) {
    plot(fastqc_summary_plot$p.qual)
    cat("\n", fill = T)
}

```

#### Sequence bias

The "sequence bias" plot shows the proportion of each base (% G, A, T and C) at each position. In a random library there would be little difference between the positions of a sequence run, so the lines in this plot should run parallel with each other. But most RNA-seq libraries show sequence imbalance in the first 10-12 read positions due to RT priming biases, which should however look fairly similar in all samples. In case the nucleotide content is summarized in a heatmap for all samples, gray colored fields represent a balanced nucleotide content.

```{r FastQC_nuc_content_summarized, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center', fig.height=min(170, ceiling(0.12*fastqc_summary_plot$no.of.samples)+1)}

if (SHINYREPS_FASTQC_SUMMARIZED) {
    plot(fastqc_summary_plot$p.content)
    cat("\n", fill = T)
} 

```

```{r FastQC_nuc_content, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center',fig.height=min(170, round((3*fastqc_summary_plot$no.of.samples)/4)+1)}

if (SHINYREPS_FASTQC_SUMMARIZED == F) {
    plot(fastqc_summary_plot$p.content)
    cat("\n", fill = T)
}
```

#### GC content

The "GC content" plot shows the GC% distribution of all reads and all samples. Typically, the lines should tightly overlap and look essentially the same in all samples. An unusually shaped distribution could indicate a contaminated library.

```{r FastQC_GC, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center'}

fastqc_summary_plot$p.gc
cat("\n", fill = T)
```



```{r cutadapt, echo=F, results='asis', error=F, warning=F, message=F, eval=runCutadapt}
##### parameters to set:
# define subset of cutadapt log files if desired (samplePattern=NULL (default) includes all files).
# define categories of targets.txt to be used for dot color in the plot (one plot per element of colorByFactor will be created). 
# The function will try to map the data from targets$file to the cutadapt log file names (for this, the unique part of 
# targets$file must be a substring of file name). If you have cutadapt log files from pooled fastq files but cell-wise 
# information in targets.txt as in MARS-Seq, you may provide another customized targets object in 'targetsdf'. 
# Otherwise pruned file names will be used by default.
#####

if(runCutadapt) {
  cat("## Adapter trimming with Cutadapt\n")
  
  cat("\nThe following plot shows the amount of reads trimmed for the selected adapter sequences including polyA/polyT sequences if specified. The column 'tooshort' gives the percentage of reads removed due to a length of less than 30 bases after trimming. Additionally to the column 'trimmed' which is for all adapters combined, there are columns for every single adapter giving the percentage of reads trimmed for this adapter.\n\n")
  
  DEhelper.cutadapt(colorByFactor=colorByFactor, targetsdf=targets4plots)
}
```

```{r FastQC_qual_summarized_trimmed, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center', eval=runCutadapt}
if(runCutadapt) {

  cat("### FastQC of trimmed reads QC\n\n")
  cat("#### Read quality\n\n")
  if (SHINYREPS_FASTQC_SUMMARIZED) {
      fastqc_summary_plot <- DEhelper.Fastqc.custom(web=F,summarizedPlots=T, targetsdf=targets4plots, subdir="trimmed", samplePattern=SHINYREPS_SAMPLEPATTERN1, excludePattern=SHINYREPS_SAMPLEPATTERN2, maxno=SHINYREPS_MAXNO)
      plot(fastqc_summary_plot$p.qual)
      cat("\n", fill = T)
  } else {
      fastqc_summary_plot <- DEhelper.Fastqc.custom(web=F,summarizedPlots=F, targetsdf=targets4plots, subdir="trimmed", samplePattern=SHINYREPS_SAMPLEPATTERN1, excludePattern=SHINYREPS_SAMPLEPATTERN2, maxno=SHINYREPS_MAXNO)
  }
}

```

```{r FastQC_qual_trimmed, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center',fig.height=min(170, round((3*fastqc_summary_plot$no.of.samples)/4)+1), eval=runCutadapt}
if(runCutadapt) {
  
  if (SHINYREPS_FASTQC_SUMMARIZED == FALSE) {
      plot(fastqc_summary_plot$p.qual)
      cat("\n", fill = T)
  }
}
```

```{r FastQC_nuc_content_summarized_trimmed, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center', fig.height=min(170, ceiling(0.12*fastqc_summary_plot$no.of.samples)+1), eval=runCutadapt}

if(runCutadapt) {

  cat("#### Sequence bias of trimmed reads\n")
  
  if (SHINYREPS_FASTQC_SUMMARIZED) {
      plot(fastqc_summary_plot$p.content)
      cat("\n", fill = T)
  }
}
```

```{r FastQC_nuc_content_trimmed, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center',fig.height=min(170, round((3*fastqc_summary_plot$no.of.samples)/4)+1), eval=runCutadapt}
if(runCutadapt) {

  if (SHINYREPS_FASTQC_SUMMARIZED == F) {
      plot(fastqc_summary_plot$p.content)
      cat("\n", fill = T)
  }
}
```

```{r FastQC_GC_trimmed, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center', eval=runCutadapt}
if(runCutadapt) {

  cat("#### GC content of trimmed reads\n")
  fastqc_summary_plot$p.gc
  cat("\n", fill = T)
}
```


# Mapping Statistics

```{r cellranger_mapping_stats, results='asis', message=FALSE, warning=FALSE, eval=nrow(targets)>100}

cat("\nMapping Statistics can be found in the cellranger web summary.\n")

```


## Competitive mapping to potential contaminants:

A competitive mapping to the reference genome and known rRNAs (H. sapiens, M. musculus, C. elegans, D. melanogaster, D. rerio, X. tropicalis) as well as frequently occurring Mycoplasma species (M. arginini, M. fermentans, M. hominis, M. hyorhinis, M. orale, and Acholeplasma laidlawii), PhiX and ERCC spike-in sequences, E. coli and B. taurus (bovine) was performed with FastQScreen (http://www.bioinformatics.babraham.ac.uk/projects/fastq_screen/).

In the following plot only relevant contaminants are shown. A contaminant is considered relevant if it consumes `r SHINYREPS_FASTQSCREEN_PERC`% of reads or more in at least one sample. The "one genome" label refers to the amount of reads mapping to that genome only, no matter if they are mapping uniquely or multiple times. The "multiple genome" label refers to the amount of read mapping to this genome but also to other genomes in the screening regardless of whether they are uniquely or multi mapping. 

```{r fastqscreen_paragraph, echo=F, results='asis', fig.width=10, error=F, warning=F, message=F}
fastqscreen_plots <- DEhelper.fastqscreen(perc.to.plot=SHINYREPS_FASTQSCREEN_PERC, ncol=3, targetsdf=targets4plots, samplePattern=SHINYREPS_SAMPLEPATTERN1, excludePattern=SHINYREPS_SAMPLEPATTERN2, maxno=SHINYREPS_MAXNO)
```

```{r fastqscreen_paragraph2, echo=F,results='asis',error=F,warning=F,message=F,fig.align='center', fig.height=min(170, (round((1.5*fastqscreen_plots$no.of.rows))+1)*fastqscreen_plots$no.of.samples/8+1)}
  if(is.null(fastqscreen_plots$errortext)) {
    plot(fastqscreen_plots$p.category.wrap)
    } else {
      cat(fastqscreen_plots$errortext)
      }
```




# Joint RNA and ATAC analysis

This processing pipeline is based mainly on the Signac vignettes from Stuart Lab:

* [Joint RNA and ATAC analysis](https://stuartlab.org/signac/articles/pbmc_multiomic.html)

`Signac` is an R package for single cell ATAC-seq analysis from the Satija lab [(Stuart et al., 2021)](https://doi.org/10.1038/s41592-021-01282-5). This is also the lab behind the popular single cell RNA-seq R package `Seurat` [(Stuart et al., 2019)](https://doi.org/10.1016/j.cell.2019.05.031).

The main `Signac` vignette overview page is at: [https://satijalab.org/signac/articles/overview.html](https://satijalab.org/signac/articles/overview.html)

Also useful is the main `Seurat` vignettes overview page, as Signac builds on Seurat: [https://satijalab.org/seurat/articles/get_started.html](https://satijalab.org/seurat/articles/get_started.html)



## Call peaks in Seurat (NOT YET IMPLEMENTED)

```{r new_peak_calling, echo=F, message=FALSE, error=TRUE, warning=TRUE, eval=F}
if(F) {
cat("## Peak calling\n\n")
  
cat("\nThe set of peaks identified using Cellranger often merges distinct peaks that are close together. This can create a problem for certain analyses, particularly motif enrichment analysis and peak-to-gene linkage. To identify a more accurate set of peaks, we can call peaks using MACS2 with the CallPeaks() function. Here we call peaks on all cells together, but we could identify peaks for each group of cells separately by setting the group.by parameter, and this can help identify peaks specific to rare cell populations.\n")

# call peaks using MACS2
peaks <- CallPeaks(sobj, assay = "ATAC", group.by="sample") 

# remove peaks on nonstandard chromosomes and in genomic blacklist regions
# blacklist_hg38_unified comes with Signac package
peaks <- keepStandardChromosomes(peaks, pruning.mode = "coarse")
peaks <- subsetByOverlaps(x = peaks, ranges = blacklist_hg38_unified, invert = TRUE) 

# quantify counts in each peak
macs2_counts <- FeatureMatrix(
  fragments = Fragments(sobj),
  features = peaks,
  cells = colnames(sobj)
)

# create a new assay using the MACS2 peak set and add it to the Seurat object
sobj[["peaks"]] <- CreateChromatinAssay(
  counts = macs2_counts,
  fragments = fragpath,
  annotation = gtf 
)
}

```


## Quality control

We can compute per-cell quality control metrics using the DNA accessibility data and remove cells that are outliers for these metrics, as well as cells with low or unusually high counts for either the RNA or ATAC assay.


### Nucleosome signal

The histogram of DNA fragment sizes (determined from the paired-end sequencing reads) should exhibit a strong nucleosome banding pattern corresponding to the length of DNA wrapped around a single nucleosome. We calculate this per single cell, and quantify the approximate ratio of mononucleosomal to nucleosome-free fragments.

```{r atac_qc_nucleosome_signal, echo=F, message=FALSE, error=FALSE, warning=FALSE}

knitr::include_graphics(file.path(SHINYREPS_SC_QC_OUT, "atac_qc_fragmentsizes_hist.png"))

```


### TSS enrichment

Transcriptional start site (TSS) enrichment score. The ENCODE project has defined an ATAC-seq targeting score based on the ratio of fragments centered at the TSS to fragments in TSS-flanking regions (see https://www.encodeproject.org/data-standards/terms/). Poor ATAC-seq experiments typically will have a low TSS enrichment score.

```{r atac_qc_tss_enrichment, echo=F, message=FALSE, error=FALSE, warning=FALSE}

knitr::include_graphics(file.path(SHINYREPS_SC_QC_OUT, "atac_qc_tss_enrich_profiles.png"))

```

Read counts per cell in RNA and ATAC experiment (nCount_RNA, nCount_ATAC): A measure of cellular sequencing depth / complexity. Cells with very few reads may need to be excluded due to low sequencing depth. Cells with extremely high levels may represent doublets, nuclei clumps, or other artefacts.


```{r qcVlnplot, echo=F, message=FALSE, error=FALSE, warning=FALSE}

knitr::include_graphics(file.path(SHINYREPS_SC_QC_OUT, "qc_violin_plot.png"))

```


### Filter for QC thresholds

The following criteria are applied for QC filtering.

```{r qc_filter, echo=F, message=FALSE, error=TRUE, warning=TRUE}

qcFilt <- read.table(file.path(SHINYREPS_SC_QC_OUT, "qc_filtering.txt"), sep="\t", header=T)
kbl(qcFilt, caption="QC filtering", row.names=F) %>% kable_styling()

knitr::include_graphics(file.path(SHINYREPS_SC_QC_OUT, "qc_filt_violin_plot.png"))

```


## Gene expression data processing

We can normalize the gene expression data using SCTransform as described in [Hafemeister and Satija, 2019](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1874-1). This procedure omits the need for heuristic steps including pseudocount addition or log-transformation and improves common downstream analytical tasks such as variable gene selection, dimensional reduction, and differential expression.

```{r process_RNA, results=FALSE, echo=F, message=FALSE, error=TRUE, warning=TRUE}

load(file.path(SHINYREPS_SCTRANSFORM_OUT, "SCTransform.RData"))
patchwork::wrap_plots(sctUmapCluster, sctUmapSample, ncol = 2)

```


## DNA accessibility data processing

Here we process the DNA accessibility assay the same way we would process a scATAC-seq dataset, by performing latent semantic indexing (LSI).

* Normalization: Signac performs term frequency-inverse document frequency (TF-IDF) normalization. This is a two-step normalization procedure, that both normalizes across cells to correct for differences in cellular sequencing depth, and across peaks to give higher values to more rare peaks.

* Feature selection: The low dynamic range of scATAC-seq data makes it challenging to perform variable feature selection, as we do for scRNA-seq. Instead, we can choose to use only the top n% of features (peaks) for dimensional reduction, or remove features present in less than n cells with the FindTopFeatures() function. Here, we will all features, though we note that we see very similar results when using only a subset of features (try setting min.cutoff to ‘q75’ to use the top 25% all peaks), with faster runtimes. Features used for dimensional reduction are automatically set as VariableFeatures() for the Seurat object by this function.

* Dimension reduction: We next run singular value decomposition (SVD) on the TD-IDF matrix, using the features (peaks) selected above. This returns a reduced dimension representation of the object (for users who are more familiar with scRNA-seq, you can think of this as analogous to the output of PCA).


Plot correlations of LSI components with read depth. The first LSI component often captures sequencing depth (technical variation) rather than biological variation. If we see a very strong correlation between the first LSI component and the total number of counts for the cell, this component should be removed from downstream analysis. 

```{r atac_plot_lsi_depth_corr, echo=F, message=F, error=F, warning=T}

knitr::include_graphics(file.path(SHINYREPS_DNAACCESS_OUT, "atac_lsi_depth_corr_plot.png"))

```


### ATAC data clustering

Cluster using the `FindNeighbors()` and `FindClusters()` functions from the `Seurat` package. Seurat's [FindClusters](https://satijalab.org/seurat/reference/findclusters) uses a graph clustering algorithm operating on the shared nearest neighbors (SNN) graph, with modularity detection.
The first LSI component is omitted, which is anti-correlated with the read depth per nucleus.

Plot UMAP colored by cluster and by sample.

```{r atac_umap_clusters}

load(file.path(SHINYREPS_DNAACCESS_OUT, "DNAaccess.RData"))
patchwork::wrap_plots(atacUmapCluster, atacUmapSample, ncol = 2)

```


## Joint UMAP visualization

Using the weighted nearest neighbor (WNN) methods in Seurat v4, we can compute a joint neighbor graph that represent both the gene expression and DNA accessibility measurements.

```{r wnn_plot, echo=F, message=FALSE, error=F, warning=F}

load(file.path(SHINYREPS_SCWNN_OUT, "wnn.RData"))
patchwork::wrap_plots(umapSample, tsneSample, ncol = 2)

```


### WNN clustering

The calculated WNN graph is now used for clustering.

```{r WNNclustering, echo=F, message=FALSE, error=TRUE, warning=TRUE}

WNNumap

```


## Annotating cell types


### Annotate with Seurat

To annotate cell types in the dataset we can transfer cell labels from an existing reference dataset using tools in the Seurat package. The main steps of this procedure are outlined below. For a more detailed description of the methodology, please see the Seurat reference mapping vignette and Stuart, Butler, et al Cell 2019. doi: 10.1016/j.cell.2019.05.031; doi: 10.1101/460147

* Perform dimensional reduction. 

* Identify anchors between the reference and query-pairs of cells from each dataset that are contained within each other's neighborhoods (also known as mutual nearest neighbors).

* Filter low confidence anchors to ensure anchors in the low dimension space are in broad agreement with the high dimensional measurements. This is done by looking at the neighbors of each query cell in the reference dataset using max.features to define this space. If the reference cell isn't found within the first k.filter neighbors, remove the anchor.

* Assign each remaining anchor a score. For each anchor cell, determine the nearest k.score anchors within its own dataset and within its pair's dataset. Based on these neighborhoods, construct an overall neighbor graph and then compute the shared neighbor overlap between anchor and query cells (analogous to an SNN graph). We use the 0.01 and 0.90 quantiles on these scores to dampen outlier effects and rescale to range between 0-1.


```{r cell_types, echo=F, message=FALSE, error=TRUE, warning=TRUE}

if(file.exists(file.path(SHINYREPS_CTANNOSEURAT_OUT, "umap_anno_Seurat_celltypeanno.png"))) {
knitr::include_graphics(file.path(SHINYREPS_CTANNOSEURAT_OUT, "umap_anno_Seurat_celltypeanno.png"))
} else {
  cat("Celltype annotation with Seurat was not applied")
}

```


### Annotating cell types using Marker Genes

Using the [scType](https://github.com/IanevskiAleksandr/sc-type) tool we could perform the celltype annotation. This tool uses positive and negative marker genes to annotate a cluster to a specific celltype. The marker gene set includes data from the CellMarkerDB, PangaloDB and some additional manually curated gene (especially negative markers) from literature. This method currently seems to be better than any other competing tool, in terms of flexibility to use, speed, and accuracy (good performance even up-to 80% dropout rates on simulations) especially in identifying rare (but known) celltypes and distinguishing closely related celltypes. When a cluster contains scType score (which is used to annotate clusters) lower than one-fourth of the number of cells in the cluster the cluster is labelled as unknown. 

```{r cell_types_markerbased, echo=F, message=FALSE, error=TRUE, warning=TRUE}

if(file.exists(file.path(SHINYREPS_CTANNOMARKER_OUT, "umap_anno_scType_WNNcluster_celltypeanno.png"))) {
knitr::include_graphics(file.path(SHINYREPS_CTANNOMARKER_OUT, "umap_anno_scType_WNNcluster_celltypeanno.png"))
} else {
  cat("Celltype annotation with scType was not applied")
}

```


```{r pickCTanno, echo=F, message=FALSE, error=TRUE, warning=TRUE}

# select the cell type annotation to be used in downstream analysis
if(!is.null(SHINYREPS_CTANNOSELECTED) && !is.na(SHINYREPS_CTANNOSELECTED)) {
  switch(SHINYREPS_CTANNOSELECTED,
       Seurat={ celltype <- "predicted.id" },
       Marker={ celltype <- "CTAnnotationSCType" },
       stop(c("Don't find cell type annotation"))   
  )
  cat(paste0("We used the cell type annotation option '", SHINYREPS_CTANNOSELECTED, "' for downstream analysis (i.e. annotation column '", celltype, "').\n"))  

} else {
  cat("no cell type annotation selected")
}

```


## Linking peaks to genes

For each gene, we can find the set of peaks that may regulate the gene by by computing the correlation between gene expression and accessibility at nearby peaks, and correcting for bias due to GC content, overall accessibility, and peak size. See the Signac paper for a full description of the method we use to link peaks to genes.

Running this step on the whole genome can be time consuming, so here we demonstrate peak-gene links for a subset of genes as an example. The same function can be used to find links for all genes by omitting the genes.use parameter:


```{r link_peaks2genes, echo=F, message=FALSE, error=TRUE, warning=TRUE}

# We can visualize these links using the CoveragePlot() function, or alternatively we could use the CoverageBrowser() function in an interactive analysis.

# Plot frequency of Tn5 insertion events (accessibility) for different groups of cells within given regions of the genome. 
# Tracks are normalized using a per-group scaling factor computed as the number of cells in the group multiplied by the
# mean sequencing depth for that group of cells. This accounts for differences in number of cells and potential differences 
# in sequencing depth between groups. 
 
if(file.exists(file.path(SHINYREPS_PEAKS2GENES_OUT, "peaks2genes_CoveragePlot.png"))) {
knitr::include_graphics(file.path(SHINYREPS_PEAKS2GENES_OUT, "peaks2genes_CoveragePlot.png"))
} else {
  cat("no peaks2genes coverage plot found")
}

```


Note that Cell Ranger ARC already does such peak-to-gene linking based on correlating peak accessibility to gene expression. However, this data is based on the Cell Ranger Arc output and does not consider the filtering and processing routines applied here. An excerpt of this feature linkage data is given below. For full results see table 'Cellranger_feature_linkage.txt'. 

```{r cellrangerMotifCount, echo=F, message=FALSE, error=TRUE, warning=TRUE}

if(file.exists(file.path(SHINYREPS_CRMOTIFCOUNTS_OUT, "Cellranger_feature_linkage.txt"))) {
CR_featureLinkage <- read.table(file=file.path(SHINYREPS_CRMOTIFCOUNTS_OUT, "Cellranger_feature_linkage.txt"), header=T, sep="\t")
kbl(CR_featureLinkage[1:min(10,nrow(CR_featureLinkage)), ], caption="Excerpt of Cellranger feature linkage results", row.names=F) %>% kable_styling()
} else {
  cat("Cellranger feature linkage table not found")
}

```



## Gene activity and peak co-accessibility network (NOT YET IMPLEMENTED)

Gene activity is the sum of the open chromatin signal associated with a particular gene. It allows converting the peak-level ATAC dat to gene-level ATAC data. This allows plotting gene-associated chromatin accessibility levels in the UMAP or t-SNE plots, and also mapping and/or merging different datasets (like scRNA-seq with scATAC-seq).

There are two approaches to this:

* Signac approach: This is a very simple approach that simply counts fragments in gene bodies and promoters.
* [Cicero approach](https://cole-trapnell-lab.github.io/cicero-release/docs_m3/#cicero-gene-activity-scores): This is more sophisticated and looks for correlations between accessible regions, including the gene promoters, across cells/nuclei.

Here we use the simple Signac approach.

```{r atac_gene_activity_signac, eval=FALSE}

gene.activities <- GeneActivity(sobj)

# Add the gene activity matrix to the Seurat object as a new assay and normalize it
sobj[['GeneActivities']] <- CreateAssayObject(counts = gene.activities)
sobj <- NormalizeData(
  object = sobj,
  assay = 'GeneActivities',
  normalization.method = 'LogNormalize',
  scale.factor = median(sobj$nCount_RNA)
)

saveRDS(gene.activities, file = file.path("report_files", "R_gene_activities.RDS"))
gc()

```

Plot gene activity of specific genes

```{r atac_plot_gene_activity_signac, eval=FALSE}

DefaultAssay(sobj) <- 'GeneActivities'

FeaturePlot(
  object = sobj,
  features = c('SYN1', 'CAMK2A', 'AQP4', 'OLIG1', 'PDGFRA', 'TMEM119'),
  pt.size = 0.1,
  max.cutoff = 'q95',
  ncol = 3
)

DefaultAssay(sobj) <- 'ATAC'

```


### Cicero peak co-accessibility network and gene activity (NOT YET IMPLEMENTED)

Here we use Cicero to calculate a cis-co-accessibility network (CCAN), and then to calculate gene activity scores based on it.

Cicero cis-co-accessibility network (CCAN). From [Signac Cicero vignette](https://satijalab.org/signac/articles/cicero.html)

```{r atac_cicero_ccan}


```

Cicero gene activities. From [Cicero website vignette](https://cole-trapnell-lab.github.io/cicero-release/docs_m3/#cicero-gene-activity-scores)

```{r atac_cicero_gene_activity}


```



## Differentially accessible peaks

### Identify differentially accessible peaks between all pairs of groups for each cluster 
See full results in 'peaks_diffacces_clusters.xlsx'.

```{r atac_differentially_accessible_peaks, results='asis', echo=F, message=FALSE, error=F, warning=F}

# differential accessibility between pairs of samples calculated per cluster

load(file.path(SHINYREPS_DIFFPEAKS_OUT, "diffPeaks.RData"))
for (i in names(da_groups_atac)) {
  cat(paste("\nComparison", i, "\n"))
  print(kbl(da_groups_atac[[i]][1:min(10,nrow(da_groups_atac[[i]])), ], caption=paste("Top differentially accessible peaks between pairs of groups per cluster:", i), format="simple", align = "l", row.names=T) %>% kable_styling(full_width = F))
}

```

### Identify differentially accessible peaks between all pairs of groups for each celltype
See full results in 'peaks_diffacces_celltypes.xlsx'.

```{r atac_differentially_accessible_peaks_by_celltype, results='asis', echo=F, message=FALSE, error=F, warning=F}

## differential accessibility between pairs of samples calculated per celltype
for (i in names(da_groups_atac_ct)) {
  cat(paste("\nComparison", i, "\n"))
  print(kbl(da_groups_atac_ct[[i]][1:min(10,nrow(da_groups_atac_ct[[i]])), ], caption=paste("Top differentially accessible peaks between pairs of groups per celltype:", i), format="simple", align = "l", row.names=T) %>% kable_styling(full_width = F))
}

```


## Motif enrichment analysis for differentially accessible peaks
To identify potentially important cell-type-specific regulatory sequences, we can search for DNA motifs that are over-represented in a set of peaks that are differentially accessible between clusters or cell types (see above). This is done by computing the number of features containing the motif (observed) and comparing this to the total number of features containing the motif (background) using the hypergeometric test.

The list of motif position frequency matrices is taken from the JASPAR database via Bioconductor's `JASPAR2020` package. This code is implemented for human and mouse. For more information see [Signac Motif Vignette](https://stuartlab.org/signac/articles/motif_vignette.html).

### Identify enriched motifs in differentially accessible peaks per cluster
See full results in 'motif_enriched_clusters.xlsx'.

```{r atac_motifs_da_peaks, results='asis', echo=F, message=FALSE, error=F, warning=F}

load(file.path(SHINYREPS_MOTIFENRICH_OUT, "motifEnrich.RData"))
for (i in names(da_enriched_motifs)) {
  cat(paste("\nComparison", i, "\n"))
  print(kbl(da_enriched_motifs[[i]][1:min(10,nrow(da_enriched_motifs[[i]])), ], caption=paste("Enriched motifs (top 10) for differentially accessible peaks between pairs of groups per cluster:", i), format="simple", align = "l", row.names=T) %>% kable_styling(full_width = F))
}

```

### Identify enriched motifs in differentially accessible peaks per celltype 
See full results in 'motif_enriched_celltypes.xlsx'.

```{r atac_motifs_da_peaks_by_celltype, results='asis', echo=F, message=FALSE, error=F, warning=F}

for (i in names(da_enriched_motifs_ct)) {
  cat(paste("\nComparison", i, "\n"))
  print(kbl(da_enriched_motifs_ct[[i]][1:min(10,nrow(da_enriched_motifs_ct[[i]])), ], caption=paste("Enriched motifs (top 10) for differentially accessible peaks between pairs of groups per celltype:", i), format="simple", align = "l", row.names=T) %>% kable_styling(full_width = F))
}

```


## Motif activity between clusters and cell types

We can also compute a per-cell motif activity score by running `chromVAR`. This allows us to visualize motif activities per cell, and also provides an alternative method of identifying differentially-active motifs between clusters and cell types. ChromVAR identifies motifs associated with variability in chromatin accessibility between cells. See the [chromVAR paper](https://www.nature.com/articles/nmeth.4401#Sec3) for a complete description of the method. Here, we test for differential activity scores between each cluster/cell type compared with all other clusters/cell types.

The list of motif position frequency matrices is taken from the JASPAR database via Bioconductor's `JASPAR2020` package. This code is implemented for human and mouse. For more information see [Signac Motif Vignette](https://stuartlab.org/signac/articles/motif_vignette.html).

### Calculate differential motif activity per cluster
See full results in 'ChromVar_motif_enriched_cluster_vs_all.xlsx'.

```{r atac_motif_activity_per_cluster, results='asis', echo=F, message=FALSE, error=F, warning=F}

load(file.path(SHINYREPS_MOTIFACTIVITY_OUT, "motifActivity.RData"))
for (i in sort(names(diffAct_cluster))) {
  cat(paste("\nCluster", i, "\n"))
  print(kbl(diffAct_cluster[[i]][1:min(10,nrow(diffAct_cluster[[i]])), ], caption=paste("Motifs with differential activity scores (top 10) for cluster:", i, "compared to all other clusters"), format="simple", align = "l", row.names=T) %>% kable_styling(full_width = F))
}

```

### Calculate differential motif activity per cell type 
See full results in 'ChromVar_motif_enriched_celltype_vs_all.xlsx'.

```{r atac_motif_activity_per_celltype, results='asis', echo=F, message=FALSE, error=F, warning=F}

for (i in sort(names(diffAct_ct))) {
  cat(paste("\nCell type", i, "\n"))
  print(kbl(diffAct_ct[[i]][1:min(10,nrow(diffAct_ct[[i]])), ], caption=paste("Motifs with differential activity scores (top 10) for cell type:", i, "compared to all other cell types"), format="simple", align = "l", row.names=T) %>% kable_styling(full_width = F))
}

```


## Differentially expressed genes

### Identify differentially expressed genes between all pairs of groups for each cluster 
See full results in 'diffExpr_clusters.xlsx'.

```{r diff_expr, results='asis', echo=F, message=FALSE, error=F, warning=F}

# differentially expressed genes between pairs of samples calculated per cluster
load(file.path(SHINYREPS_DIFFEXPR_OUT, "diffExprSeurat.RData"))
for (i in names(diffExpr_groups)) {
  cat(paste("\nComparison", i, "\n"))
  print(kbl(diffExpr_groups[[i]][1:min(10,nrow(diffExpr_groups[[i]])), ], caption=paste("Top differentially expressed genes between pairs of groups per cluster:", i), format="simple", align = "l", row.names=T) %>% kable_styling(full_width = F))
}

```

### Identify differentially expressed genes between all pairs of groups for each celltype 
See full results in 'diffExpr_celltypes.xlsx'.

```{r diff_expr_by_celltype, results='asis', echo=F, message=FALSE, error=F, warning=F}

## differentially expressed genes between pairs of samples calculated per celltype
for (i in names(diffExpr_groups_ct)) {
  cat(paste("\nComparison", i, "\n"))
  print(kbl(diffExpr_groups_ct[[i]][1:min(10,nrow(diffExpr_groups_ct[[i]])), ], caption=paste("Top differentially expressed genes between pairs of groups per celltype:", i), format="simple", align = "l", row.names=T) %>% kable_styling(full_width = F))
}

```



## Gene Regulatory Networks

Pando leverages multi-modal single-cell measurements to infer gene regulatory networks using a flexible linear model-based framework. By modeling the relationship between TF-binding site pairs with the expression of target genes, Pando simultaneously infers gene modules and sets of regulatory regions for each transcription factor.

The fate and state of a cell is regulated through complex circuits of transcription factors (TFs) converging at regulatory elements to enable precise control of gene expression. Modern single-cell genomic approaches allow the simultaneous profiling of gene expression and chromatin accessibility in individual cells, which opens up new opportunities for the inference of gene regulatory networks (GRNs). Pando jointly utilizes scRNA-seq and scATAC-seq data to infer regulatory relationships between TFs and target genes.

The unifying idea behind many modern GRN inference methods is to model the expression of each gene as a function of TF abundances. The weights or coefficients of this model can then be interpreted as a measure of the regulatory interaction between TF and target gene. Pando tries to generalize this concept to make use of the multi-modal nature of modern single-cell technologies by incorporating TF binding information directly into the model. By utilizing jointly measured or integrated scRNA-seq and scATAC-seq data, Pando models the expression of genes based on the interaction of TF expression with the accessibility of their putative binding site.

Module extraction (see full results in 'GRN_TF_modules.txt'):
```{r pando1, echo=F, message=FALSE, error=F, warning=F}

load(file.path(SHINYREPS_GRN_OUT, "grn.RData"))
kbl(modules_df[1:min(20,nrow(modules_df)),], align = "l", format="simple", caption="Identified TF modules (i.e. the set of genes that are regulated by each transcription factor, first 20 entries)") %>% kable_styling(full_width = F)

```

Plot goodness-of-fit metrics of the fitted models. This shows us the explained variance of the model, as well as the number of variables in each model. We can observe that with more variables, the models will have a better fit. The dashed lines show the applied thresholds for in the find_modules function.

```{r pando2, echo=F, message=FALSE, error=F, warning=F}

if(file.exists(file.path(SHINYREPS_GRN_OUT, "GRN_goodness_of_fit_metrics.pdf"))) {
knitr::include_graphics(file.path(SHINYREPS_GRN_OUT, "GRN_goodness_of_fit_metrics.png"))
} else {
  cat("no plot found")
}

```

Plot size of the modules with respect to the number of target genes as well as the number of peaks and regulating TFs per target gene.

```{r pando3, echo=F, message=FALSE, error=F, warning=F}

if(file.exists(file.path(SHINYREPS_GRN_OUT, "GRN_module_metrics.png"))) {
knitr::include_graphics(file.path(SHINYREPS_GRN_OUT, "GRN_module_metrics.png"))
} else {
  cat("no plot found")
}

```

Visualization of the network graph. The nodes are colored and sized based on their centrality in the graph and the edges are colored by the direction of the regulation (inhibitory: grey; activating: orange)

```{r pando4, echo=F, message=FALSE, error=F, warning=F}

if(file.exists(file.path(SHINYREPS_GRN_OUT, "GRN_network_graph.pdf"))) {
knitr::include_graphics(file.path(SHINYREPS_GRN_OUT, "GRN_network_graph.png"))
} else {
  cat("no plot found")
}

```




```{r store_data, echo=F, message=FALSE, error=F, warning=F, eval=T}

# store colData in report_files folder (csv file without numerical columns for compatibility with Loupe import)
write.table(sobj[[]][, !sapply(sobj[[]], is.numeric)], file="report_files/cells.csv", sep=",", quote = F, row.names = F)

# store projections (csv file for compatibility with Loupe import)
dir_projections <- file.path("report_files", "projections")
if (!file.exists(dir_projections)) {dir.create(dir_projections, recursive = T)}

for (p in names(sobj@reductions)) {
  projection <- data.frame(
    Barcode=rownames(Embeddings(sobj, reduction = p)),
    X=Embeddings(sobj, reduction = p)[,1],
    Y=Embeddings(sobj, reduction = p)[,2]
  )
  write.table(projection, file =file.path(dir_projections, paste0(p, ".csv")), sep=",", quote = F, row.names = F)
  }

# store pruned Seurat object in h5ad format
if(!file.exists(file.path("report_files", "sobj.h5Seurat"))) {
DefaultAssay(sobj) <- "RNA"
if("ATAC" %in% names(sobj)) {sobj[["ATAC"]] <- NULL} # some objects in this slot are not compatible with conversion
if("SCT" %in% names(sobj)) {sobj[["SCT"]] <- NULL}
SaveH5Seurat(sobj, filename = file.path("report_files", "sobj.h5Seurat"))
Convert(file.path("report_files", "sobj.h5Seurat"), dest = "h5ad")
} else {
cat("\nWriting sobj.h5Seurat is omitted because file already exists.\n")  
}

```


# Used tools and versions for this analysis ##

Read mapping was performed with STAR using the following parameters:

```{r STAR_parameters_paragraph, echo=F, results='asis', error=F, warning=F, message=F}
cat(DEhelper.STARparms(), sep="\n")
``` 

The following tools were used for data processing:

```{r ToolVersions_paragraph, echo=F, results='asis', error=F, warning=F, message=F}
cat(Toolhelper.ToolVersions(), sep="\n")
```

R session info:

```{r R_sessionInfo, echo=F, results='asis', error=F, warning=F, message=F}
sessionInfo()
```

</div>

